/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/entry.js":
/*!*************************!*\
  !*** ./src/js/entry.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/shaders */ \"./src/js/modules/shaders.js\");\n/* harmony import */ var _modules_calc_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/calc-utils */ \"./src/js/modules/calc-utils.js\");\n/* harmony import */ var _modules_OrbitControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/OrbitControls */ \"./src/js/modules/OrbitControls.js\");\n/* harmony import */ var _modules_OrbitControls__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_modules_OrbitControls__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar btnSoundOn = document.getElementById(\"btn-launch-sound-on\");\nvar btnSoundOff = document.getElementById(\"btn-launch-sound-off\");\nvar loadingScreen = document.getElementById('loadingScreen');\nvar ui = document.getElementById('ui');\nvar starsAmount = 5000;\nvar status = {\n  isPlaying: false\n};\nvar stage = document.getElementById('stage');\nvar scene;\nvar camera;\nvar renderer;\nvar control;\nvar stars;\nvar timers;\nvar veloYs;\nvar renderStartTime;\nvar visibleFlags; //sound関連の読み込みと初期化\n\nvar sound = new Howl({\n  src: ['./statics/sound/Niagara.mp3'],\n  loop: false\n});\nvar isSoundLoaded = false;\nsound.once('load', function () {\n  sound.volume(0.3);\n  isSoundLoaded = true;\n});\n\nvar playSound = function playSound() {\n  setTimeout(function () {\n    sound.play();\n  }, 2000);\n};\n\nvar hideUi = function hideUi() {\n  ui.classList.remove('active');\n}; //演出終了後の初期化\n\n\nvar reset = function reset() {\n  scene.children.forEach(function (child) {\n    child.geometry.dispose();\n    child.material.dispose();\n  });\n  scene.children = [];\n  scene.dispose();\n  scene = undefined;\n  renderer = undefined;\n  camera = undefined;\n  control = undefined;\n  timers = undefined;\n  veloYs = undefined;\n  renderStartTime = undefined;\n  visibleFlags = undefined;\n  ui.classList.add('active');\n  init();\n  status.isPlaying = false;\n};\n\nvar setEndTimer = function setEndTimer() {\n  setTimeout(reset, 100000);\n};\n\nvar start = function start() {\n  status.isPlaying = true;\n  render();\n  setEndTimer();\n  renderStartTime = performance.now();\n}; //トリガー\n\n\nbtnSoundOn.addEventListener('click', function () {\n  hideUi();\n  setTimeout(function () {\n    start();\n    playSound();\n  }, 1500);\n});\nbtnSoundOff.addEventListener('click', function () {\n  hideUi();\n  setTimeout(function () {\n    start();\n  }, 1500);\n});\n\nvar init = function init() {\n  visibleFlags = new Float32Array(starsAmount);\n  timers = [];\n  veloYs = [];\n\n  for (var i = 0; i < starsAmount; i++) {\n    timers.push(Math.random() * (90000 - 30000) + 30000);\n    veloYs.push(Math.random() * (0.004 - 0.001) + 0.001);\n  }\n\n  scene = new THREE.Scene();\n  renderer = new THREE.WebGLRenderer({\n    alpha: true\n  }); // renderer.setClearColor(0x00192E);\n\n  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n  camera.position.set(0, 0, 14);\n  onResize();\n\n  if (stage.lastChild) {\n    stage.removeChild(stage.lastChild);\n  }\n\n  stage.appendChild(renderer.domElement);\n  initStars();\n  initClanes();\n  control = new THREE.OrbitControls(camera, renderer.domElement);\n  control.autoRotate = true;\n  control.autoRotateSpeed = 0.3;\n};\n\nvar onResize = function onResize() {\n  var width = window.innerWidth;\n  var height = window.innerHeight;\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(width, height);\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n};\n\nvar initStars = function initStars() {\n  var positions = new Float32Array(starsAmount * 3);\n  var pOpacities = new Float32Array(starsAmount);\n  var pSizes = new Float32Array(starsAmount);\n  var pColors = new Float32Array(starsAmount * 3);\n  var vertex = new THREE.Vector3();\n  var color = new THREE.Color(0xffffff);\n\n  for (var i = 0; i < starsAmount; i++) {\n    if (i < starsAmount / 2) {\n      vertex.x = i / 250 - starsAmount / 2 / 250;\n      vertex.y = _modules_calc_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getEaseOutPos(i, 3, -0.3, starsAmount / 2);\n      vertex.z = Math.random() * (0.5 - 0.45) + 0.45;\n      vertex.toArray(positions, i * 3);\n    } else {\n      vertex.x = (i - starsAmount / 2) / 250;\n      vertex.y = _modules_calc_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getEaseInPos(i - starsAmount / 2, 2.7, 0.3, starsAmount / 2);\n      vertex.z = Math.random() * (0.5 - 0.45) + 0.45;\n      vertex.toArray(positions, i * 3);\n    }\n\n    var colorDiv = Math.random();\n\n    if (colorDiv < 0.33) {\n      color.setRGB(0.9, 0.7, 0);\n    } else if (0.33 <= colorDiv && colorDiv < 0.66) {\n      color.setRGB(1, 0.8, 0.6);\n    } else {\n      color.setRGB(1, 1, 0.8);\n    }\n\n    color.toArray(pColors, i * 3);\n  }\n\n  var geo = new THREE.BufferGeometry();\n  geo.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geo.addAttribute('pOpacity', new THREE.BufferAttribute(pOpacities, 1));\n  geo.addAttribute('pSize', new THREE.BufferAttribute(pSizes, 1));\n  geo.addAttribute('pColor', new THREE.BufferAttribute(pColors, 3));\n  var mat = new THREE.ShaderMaterial({\n    uniforms: {\n      time: {\n        type: \"f\",\n        value: 0.0\n      },\n      resolution: {\n        value: new THREE.Vector2(window.innerWidth, window.innerHeight)\n      }\n    },\n    vertexShader: _modules_shaders__WEBPACK_IMPORTED_MODULE_0__[\"default\"].vertex,\n    fragmentShader: _modules_shaders__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fragment,\n    depthWrite: false,\n    transparent: true,\n    alphaTest: 0.5\n  });\n  stars = new THREE.Points(geo, mat);\n  scene.add(stars);\n  var opaArr = stars.geometry.attributes.pOpacity.array;\n  opaArr.forEach(function (opa) {\n    opa = 1.0;\n  });\n};\n\nvar initClanes = function initClanes() {\n  var geo1 = new THREE.Geometry();\n  geo1.vertices.push(new THREE.Vector3(10.2, 3, 0.5));\n  geo1.vertices.push(new THREE.Vector3(11, -1, 0.3));\n  geo1.vertices.push(new THREE.Vector3(11, -1, 0.7));\n  geo1.vertices.push(new THREE.Vector3(11.3, -1, 0.5));\n  geo1.faces.push(new THREE.Face3(0, 1, 2));\n  geo1.faces.push(new THREE.Face3(0, 2, 3));\n  geo1.faces.push(new THREE.Face3(0, 3, 1));\n  geo1.faces.push(new THREE.Face3(1, 3, 2));\n  var geo2 = new THREE.Geometry();\n  geo2.vertices.push(new THREE.Vector3(-10.2, 3, 0.5));\n  geo2.vertices.push(new THREE.Vector3(-11, -1, 0.3));\n  geo2.vertices.push(new THREE.Vector3(-11, -1, 0.7));\n  geo2.vertices.push(new THREE.Vector3(-11.3, -1, 0.5));\n  geo2.faces.push(new THREE.Face3(0, 1, 2));\n  geo2.faces.push(new THREE.Face3(0, 2, 3));\n  geo2.faces.push(new THREE.Face3(0, 3, 1));\n  geo2.faces.push(new THREE.Face3(1, 3, 2));\n  var mat = new THREE.MeshNormalMaterial();\n  var clane1 = new THREE.Mesh(geo1, mat);\n  scene.add(clane1);\n  var clane2 = new THREE.Mesh(geo2, mat);\n  scene.add(clane2);\n};\n\nvar render = function render() {\n  if (!status.isPlaying) return;\n  control.update();\n  animate();\n  renderer.render(scene, camera);\n  requestAnimationFrame(render);\n};\n\nvar handleOpacity = function handleOpacity(opaArr, id, timePast) {\n  if (visibleFlags[id] === 0 && id < timePast / 12) {\n    //点火してる風にみせる\n    if (Math.random() < 0.996) return;\n    visibleFlags[id] = 1;\n    visibleFlags[starsAmount - id] = 1;\n  }\n\n  if (visibleFlags[id] === 0) {\n    return;\n  } else {\n    if (Math.random() < 0.1) {\n      opaArr[id] -= 0.4;\n    }\n\n    if (opaArr[id] < 0.3) {\n      opaArr[id] = 1.0;\n    }\n  }\n};\n\nvar handlePosY = function handlePosY(posArr, i, timePast) {\n  //はしっこから落とすための調整\n  var modTimer = timers[i] - Math.abs(posArr[i * 3]) * 1500;\n\n  if (modTimer <= timePast) {\n    posArr[i * 3 + 1] -= veloYs[i];\n  }\n};\n\nvar handleColor = function handleColor(colArr, i, timePast, posArr) {\n  var modTimer = timers[i] - Math.abs(posArr[i * 3]) * 1000;\n  if (modTimer <= timePast) return;\n\n  if (50000 < timePast) {\n    colArr[i * 3] -= 0.005;\n    colArr[i * 3 + 1] += 0.005;\n    colArr[i * 3 + 2] += 0.0001;\n  }\n};\n\nvar hideIfGoaled = function hideIfGoaled(posArr, opaArr, i) {\n  if (posArr[i * 3 + 1] < -1) {\n    opaArr[i] = 0;\n  }\n};\n\nvar animate = function animate() {\n  var posArr = stars.geometry.attributes.position.array;\n  var opaArr = stars.geometry.attributes.pOpacity.array;\n  var colArr = stars.geometry.attributes.pColor.array;\n  var timePast = performance.now() - renderStartTime;\n\n  for (var i = 0; i < starsAmount; i++) {\n    handleOpacity(opaArr, i, timePast);\n    handlePosY(posArr, i, timePast);\n    handleColor(colArr, i, timePast, posArr);\n    hideIfGoaled(posArr, opaArr, i);\n  }\n\n  stars.geometry.attributes.position.needsUpdate = true;\n  stars.geometry.attributes.pOpacity.needsUpdate = true;\n  stars.geometry.attributes.pColor.needsUpdate = true;\n};\n\nwindow.onload = function () {\n  loadingScreen.classList.remove('active');\n  init();\n};\n\nwindow.addEventListener('resize', onResize);\n\n//# sourceURL=webpack:///./src/js/entry.js?");

/***/ }),

/***/ "./src/js/modules/OrbitControls.js":
/*!*****************************************!*\
  !*** ./src/js/modules/OrbitControls.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\nTHREE.OrbitControls = function (object, domElement) {\n  this.object = object;\n  this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control\n\n  this.enabled = true; // \"target\" sets the location of focus, where the object orbits around\n\n  this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )\n\n  this.minDistance = 0;\n  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )\n\n  this.minZoom = 0;\n  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n\n  this.minPolarAngle = 0; // radians\n\n  this.maxPolarAngle = Math.PI; // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n  this.minAzimuthAngle = -Infinity; // radians\n\n  this.maxAzimuthAngle = Infinity; // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n\n  this.enableDamping = false;\n  this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n\n  this.enableZoom = true;\n  this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n  this.enableRotate = true;\n  this.rotateSpeed = 1.0; // Set to false to disable panning\n\n  this.enablePan = true;\n  this.panSpeed = 1.0;\n  this.screenSpacePanning = false; // if true, pan in screen-space\n\n  this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n  this.autoRotate = false;\n  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n  // Set to false to disable use of the keys\n\n  this.enableKeys = true; // The four arrow keys\n\n  this.keys = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    BOTTOM: 40\n  }; // Mouse buttons\n\n  this.mouseButtons = {\n    LEFT: THREE.MOUSE.LEFT,\n    MIDDLE: THREE.MOUSE.MIDDLE,\n    RIGHT: THREE.MOUSE.RIGHT\n  }; // for reset\n\n  this.target0 = this.target.clone();\n  this.position0 = this.object.position.clone();\n  this.zoom0 = this.object.zoom; //\n  // public methods\n  //\n\n  this.getPolarAngle = function () {\n    return spherical.phi;\n  };\n\n  this.getAzimuthalAngle = function () {\n    return spherical.theta;\n  };\n\n  this.saveState = function () {\n    scope.target0.copy(scope.target);\n    scope.position0.copy(scope.object.position);\n    scope.zoom0 = scope.object.zoom;\n  };\n\n  this.reset = function () {\n    scope.target.copy(scope.target0);\n    scope.object.position.copy(scope.position0);\n    scope.object.zoom = scope.zoom0;\n    scope.object.updateProjectionMatrix();\n    scope.dispatchEvent(changeEvent);\n    scope.update();\n    state = STATE.NONE;\n  }; // this method is exposed, but perhaps it would be better if we can make it private...\n\n\n  this.update = function () {\n    var offset = new THREE.Vector3(); // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n    return function update() {\n      var position = scope.object.position;\n      offset.copy(position).sub(scope.target); // rotate offset to \"y-axis-is-up\" space\n\n      offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n      spherical.setFromVector3(offset);\n\n      if (scope.autoRotate && state === STATE.NONE) {\n        rotateLeft(getAutoRotationAngle());\n      }\n\n      spherical.theta += sphericalDelta.theta;\n      spherical.phi += sphericalDelta.phi; // restrict theta to be between desired limits\n\n      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits\n\n      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n      spherical.makeSafe();\n      spherical.radius *= scale; // restrict radius to be between desired limits\n\n      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location\n\n      scope.target.add(panOffset);\n      offset.setFromSpherical(spherical); // rotate offset back to \"camera-up-vector-is-up\" space\n\n      offset.applyQuaternion(quatInverse);\n      position.copy(scope.target).add(offset);\n      scope.object.lookAt(scope.target);\n\n      if (scope.enableDamping === true) {\n        sphericalDelta.theta *= 1 - scope.dampingFactor;\n        sphericalDelta.phi *= 1 - scope.dampingFactor;\n        panOffset.multiplyScalar(1 - scope.dampingFactor);\n      } else {\n        sphericalDelta.set(0, 0, 0);\n        panOffset.set(0, 0, 0);\n      }\n\n      scale = 1; // update condition is:\n      // min(camera displacement, camera rotation in radians)^2 > EPS\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n        scope.dispatchEvent(changeEvent);\n        lastPosition.copy(scope.object.position);\n        lastQuaternion.copy(scope.object.quaternion);\n        zoomChanged = false;\n        return true;\n      }\n\n      return false;\n    };\n  }();\n\n  this.dispose = function () {\n    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n    scope.domElement.removeEventListener('mousedown', onMouseDown, false);\n    scope.domElement.removeEventListener('wheel', onMouseWheel, false);\n    scope.domElement.removeEventListener('touchstart', onTouchStart, false);\n    scope.domElement.removeEventListener('touchend', onTouchEnd, false);\n    scope.domElement.removeEventListener('touchmove', onTouchMove, false);\n    document.removeEventListener('mousemove', onMouseMove, false);\n    document.removeEventListener('mouseup', onMouseUp, false);\n    window.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n  }; //\n  // internals\n  //\n\n\n  var scope = this;\n  var changeEvent = {\n    type: 'change'\n  };\n  var startEvent = {\n    type: 'start'\n  };\n  var endEvent = {\n    type: 'end'\n  };\n  var STATE = {\n    NONE: -1,\n    ROTATE: 0,\n    DOLLY: 1,\n    PAN: 2,\n    TOUCH_ROTATE: 3,\n    TOUCH_DOLLY_PAN: 4\n  };\n  var state = STATE.NONE;\n  var EPS = 0.000001; // current position in spherical coordinates\n\n  var spherical = new THREE.Spherical();\n  var sphericalDelta = new THREE.Spherical();\n  var scale = 1;\n  var panOffset = new THREE.Vector3();\n  var zoomChanged = false;\n  var rotateStart = new THREE.Vector2();\n  var rotateEnd = new THREE.Vector2();\n  var rotateDelta = new THREE.Vector2();\n  var panStart = new THREE.Vector2();\n  var panEnd = new THREE.Vector2();\n  var panDelta = new THREE.Vector2();\n  var dollyStart = new THREE.Vector2();\n  var dollyEnd = new THREE.Vector2();\n  var dollyDelta = new THREE.Vector2();\n\n  function getAutoRotationAngle() {\n    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n  }\n\n  function getZoomScale() {\n    return Math.pow(0.95, scope.zoomSpeed);\n  }\n\n  function rotateLeft(angle) {\n    sphericalDelta.theta -= angle;\n  }\n\n  function rotateUp(angle) {\n    sphericalDelta.phi -= angle;\n  }\n\n  var panLeft = function () {\n    var v = new THREE.Vector3();\n    return function panLeft(distance, objectMatrix) {\n      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\n      v.multiplyScalar(-distance);\n      panOffset.add(v);\n    };\n  }();\n\n  var panUp = function () {\n    var v = new THREE.Vector3();\n    return function panUp(distance, objectMatrix) {\n      if (scope.screenSpacePanning === true) {\n        v.setFromMatrixColumn(objectMatrix, 1);\n      } else {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.crossVectors(scope.object.up, v);\n      }\n\n      v.multiplyScalar(distance);\n      panOffset.add(v);\n    };\n  }(); // deltaX and deltaY are in pixels; right and down are positive\n\n\n  var pan = function () {\n    var offset = new THREE.Vector3();\n    return function pan(deltaX, deltaY) {\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      if (scope.object.isPerspectiveCamera) {\n        // perspective\n        var position = scope.object.position;\n        offset.copy(position).sub(scope.target);\n        var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed\n\n        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n      } else if (scope.object.isOrthographicCamera) {\n        // orthographic\n        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n      } else {\n        // camera neither orthographic nor perspective\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n        scope.enablePan = false;\n      }\n    };\n  }();\n\n  function dollyIn(dollyScale) {\n    if (scope.object.isPerspectiveCamera) {\n      scale /= dollyScale;\n    } else if (scope.object.isOrthographicCamera) {\n      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      scope.enableZoom = false;\n    }\n  }\n\n  function dollyOut(dollyScale) {\n    if (scope.object.isPerspectiveCamera) {\n      scale *= dollyScale;\n    } else if (scope.object.isOrthographicCamera) {\n      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      scope.enableZoom = false;\n    }\n  } //\n  // event callbacks - update the object state\n  //\n\n\n  function handleMouseDownRotate(event) {\n    //console.log( 'handleMouseDownRotate' );\n    rotateStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseDownDolly(event) {\n    //console.log( 'handleMouseDownDolly' );\n    dollyStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseDownPan(event) {\n    //console.log( 'handleMouseDownPan' );\n    panStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseMoveRotate(event) {\n    //console.log( 'handleMouseMoveRotate' );\n    rotateEnd.set(event.clientX, event.clientY);\n    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n    rotateStart.copy(rotateEnd);\n    scope.update();\n  }\n\n  function handleMouseMoveDolly(event) {\n    //console.log( 'handleMouseMoveDolly' );\n    dollyEnd.set(event.clientX, event.clientY);\n    dollyDelta.subVectors(dollyEnd, dollyStart);\n\n    if (dollyDelta.y > 0) {\n      dollyIn(getZoomScale());\n    } else if (dollyDelta.y < 0) {\n      dollyOut(getZoomScale());\n    }\n\n    dollyStart.copy(dollyEnd);\n    scope.update();\n  }\n\n  function handleMouseMovePan(event) {\n    //console.log( 'handleMouseMovePan' );\n    panEnd.set(event.clientX, event.clientY);\n    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n    pan(panDelta.x, panDelta.y);\n    panStart.copy(panEnd);\n    scope.update();\n  }\n\n  function handleMouseUp(event) {// console.log( 'handleMouseUp' );\n  }\n\n  function handleMouseWheel(event) {\n    // console.log( 'handleMouseWheel' );\n    if (event.deltaY < 0) {\n      dollyOut(getZoomScale());\n    } else if (event.deltaY > 0) {\n      dollyIn(getZoomScale());\n    }\n\n    scope.update();\n  }\n\n  function handleKeyDown(event) {\n    // console.log( 'handleKeyDown' );\n    var needsUpdate = false;\n\n    switch (event.keyCode) {\n      case scope.keys.UP:\n        pan(0, scope.keyPanSpeed);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.BOTTOM:\n        pan(0, -scope.keyPanSpeed);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.LEFT:\n        pan(scope.keyPanSpeed, 0);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.RIGHT:\n        pan(-scope.keyPanSpeed, 0);\n        needsUpdate = true;\n        break;\n    }\n\n    if (needsUpdate) {\n      // prevent the browser from scrolling on cursor keys\n      event.preventDefault();\n      scope.update();\n    }\n  }\n\n  function handleTouchStartRotate(event) {\n    //console.log( 'handleTouchStartRotate' );\n    rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n  }\n\n  function handleTouchStartDollyPan(event) {\n    //console.log( 'handleTouchStartDollyPan' );\n    if (scope.enableZoom) {\n      var dx = event.touches[0].pageX - event.touches[1].pageX;\n      var dy = event.touches[0].pageY - event.touches[1].pageY;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n\n    if (scope.enablePan) {\n      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n      panStart.set(x, y);\n    }\n  }\n\n  function handleTouchMoveRotate(event) {\n    //console.log( 'handleTouchMoveRotate' );\n    rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n    rotateStart.copy(rotateEnd);\n    scope.update();\n  }\n\n  function handleTouchMoveDollyPan(event) {\n    //console.log( 'handleTouchMoveDollyPan' );\n    if (scope.enableZoom) {\n      var dx = event.touches[0].pageX - event.touches[1].pageX;\n      var dy = event.touches[0].pageY - event.touches[1].pageY;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyIn(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n\n    if (scope.enablePan) {\n      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n      panEnd.set(x, y);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n\n    scope.update();\n  }\n\n  function handleTouchEnd(event) {} //console.log( 'handleTouchEnd' );\n  //\n  // event handlers - FSM: listen for events and reset state\n  //\n\n\n  function onMouseDown(event) {\n    if (scope.enabled === false) return; // Prevent the browser from scrolling.\n\n    event.preventDefault(); // Manually set the focus since calling preventDefault above\n    // prevents the browser from setting it automatically.\n\n    scope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n    switch (event.button) {\n      case scope.mouseButtons.LEFT:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          if (scope.enablePan === false) return;\n          handleMouseDownPan(event);\n          state = STATE.PAN;\n        } else {\n          if (scope.enableRotate === false) return;\n          handleMouseDownRotate(event);\n          state = STATE.ROTATE;\n        }\n\n        break;\n\n      case scope.mouseButtons.MIDDLE:\n        if (scope.enableZoom === false) return;\n        handleMouseDownDolly(event);\n        state = STATE.DOLLY;\n        break;\n\n      case scope.mouseButtons.RIGHT:\n        if (scope.enablePan === false) return;\n        handleMouseDownPan(event);\n        state = STATE.PAN;\n        break;\n    }\n\n    if (state !== STATE.NONE) {\n      document.addEventListener('mousemove', onMouseMove, false);\n      document.addEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(startEvent);\n    }\n  }\n\n  function onMouseMove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n\n    switch (state) {\n      case STATE.ROTATE:\n        if (scope.enableRotate === false) return;\n        handleMouseMoveRotate(event);\n        break;\n\n      case STATE.DOLLY:\n        if (scope.enableZoom === false) return;\n        handleMouseMoveDolly(event);\n        break;\n\n      case STATE.PAN:\n        if (scope.enablePan === false) return;\n        handleMouseMovePan(event);\n        break;\n    }\n  }\n\n  function onMouseUp(event) {\n    if (scope.enabled === false) return;\n    handleMouseUp(event);\n    document.removeEventListener('mousemove', onMouseMove, false);\n    document.removeEventListener('mouseup', onMouseUp, false);\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  function onMouseWheel(event) {\n    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n    event.preventDefault();\n    event.stopPropagation();\n    scope.dispatchEvent(startEvent);\n    handleMouseWheel(event);\n    scope.dispatchEvent(endEvent);\n  }\n\n  function onKeyDown(event) {\n    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n    handleKeyDown(event);\n  }\n\n  function onTouchStart(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n\n    switch (event.touches.length) {\n      case 1:\n        // one-fingered touch: rotate\n        if (scope.enableRotate === false) return;\n        handleTouchStartRotate(event);\n        state = STATE.TOUCH_ROTATE;\n        break;\n\n      case 2:\n        // two-fingered touch: dolly-pan\n        if (scope.enableZoom === false && scope.enablePan === false) return;\n        handleTouchStartDollyPan(event);\n        state = STATE.TOUCH_DOLLY_PAN;\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n\n    if (state !== STATE.NONE) {\n      scope.dispatchEvent(startEvent);\n    }\n  }\n\n  function onTouchMove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    event.stopPropagation();\n\n    switch (event.touches.length) {\n      case 1:\n        // one-fingered touch: rotate\n        if (scope.enableRotate === false) return;\n        if (state !== STATE.TOUCH_ROTATE) return; // is this needed?\n\n        handleTouchMoveRotate(event);\n        break;\n\n      case 2:\n        // two-fingered touch: dolly-pan\n        if (scope.enableZoom === false && scope.enablePan === false) return;\n        if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?\n\n        handleTouchMoveDollyPan(event);\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  }\n\n  function onTouchEnd(event) {\n    if (scope.enabled === false) return;\n    handleTouchEnd(event);\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  function onContextMenu(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n  } //\n\n\n  scope.domElement.addEventListener('contextmenu', onContextMenu, false);\n  scope.domElement.addEventListener('mousedown', onMouseDown, false);\n  scope.domElement.addEventListener('wheel', onMouseWheel, false);\n  scope.domElement.addEventListener('touchstart', onTouchStart, false);\n  scope.domElement.addEventListener('touchend', onTouchEnd, false);\n  scope.domElement.addEventListener('touchmove', onTouchMove, false);\n  window.addEventListener('keydown', onKeyDown, false); // force an update at start\n\n  this.update();\n};\n\nTHREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\nObject.defineProperties(THREE.OrbitControls.prototype, {\n  center: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .center has been renamed to .target');\n      return this.target;\n    }\n  },\n  // backward compatibility\n  noZoom: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n      return !this.enableZoom;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n      this.enableZoom = !value;\n    }\n  },\n  noRotate: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n      return !this.enableRotate;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n      this.enableRotate = !value;\n    }\n  },\n  noPan: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n      return !this.enablePan;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n      this.enablePan = !value;\n    }\n  },\n  noKeys: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n      return !this.enableKeys;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n      this.enableKeys = !value;\n    }\n  },\n  staticMoving: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n      return !this.enableDamping;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n      this.enableDamping = !value;\n    }\n  },\n  dynamicDampingFactor: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n      return this.dampingFactor;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n      this.dampingFactor = value;\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/modules/OrbitControls.js?");

/***/ }),

/***/ "./src/js/modules/calc-utils.js":
/*!**************************************!*\
  !*** ./src/js/modules/calc-utils.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  getEaseOutPos: function getEaseOutPos(paticleId, startVal, changeVal, numOfParticles) {\n    paticleId /= numOfParticles;\n    paticleId--;\n    return changeVal * (Math.pow(paticleId, 3) + 1) + startVal;\n  },\n  getEaseInPos: function getEaseInPos(paticleId, startVal, changeVal, numOfParticles) {\n    paticleId /= numOfParticles;\n    return changeVal * Math.pow(paticleId, 3) + startVal;\n  }\n});\n\n//# sourceURL=webpack:///./src/js/modules/calc-utils.js?");

/***/ }),

/***/ "./src/js/modules/shaders.js":
/*!***********************************!*\
  !*** ./src/js/modules/shaders.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  vertex: \"\\n    attribute float pOpacity;\\n    attribute float pSize;\\n    attribute vec3 pColor;\\n    \\n    varying vec2 vUv;\\n    varying float vOpacity;\\n    varying vec3 vColor;\\n    \\n    void main() {\\n      vUv = uv;\\n      vOpacity = pOpacity;\\n      vColor = pColor;\\n    \\n      gl_PointSize = 45.0;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n    }\\n  \",\n  fragment: \"\\n    precision mediump float;\\n\\n    varying vec2 vUv;\\n    varying float vOpacity;\\n    varying vec3 vColor;\\n\\n    uniform vec2 resolution;\\n    \\n    void main() {\\n      float dist = distance(vec2(gl_PointCoord.x, gl_PointCoord.y), vec2(0.5, 0.5));\\n\\n      vec4 baseColor = vec4(vColor, (0.02 / dist - dist * 0.4) * vOpacity);\\n\\n      gl_FragColor = baseColor;\\n\\n    }\\n  \"\n});\n\n//# sourceURL=webpack:///./src/js/modules/shaders.js?");

/***/ })

/******/ });